// 输入两个无环的单向链表，找出它们的第一个公共结点，如果没有公共节点则返回空。
// （注意因为传入数据是链表，所以错误测试数据的提示是用其他方式显示的，保证传入数据是正确的）

// 输入描述：

// 输入分为是3段，第一段是第一个链表的非公共部分，第二段是第二个链表的非公共部分，第三段是第一个链表和第二个链表的公共部分。 后台会将这3个参数组装为两个链表，并将这两个链表对应的头节点传入到函数FindFirstCommonNode里面，用户得到的输入只有pHead1和pHead2。

// 返回值描述：

// 返回传入的pHead1和pHead2的第一个公共结点，后台会打印以该节点为头节点的链表。

// 示例1
// 输入：
// {1,2,3},{4,5},{6,7}
// 返回值：
// {6,7}

// 说明：
// 第一个参数{1,2,3}代表是第一个链表非公共部分，第二个参数{4,5}代表是第二个链表非公共部分，最后的{6,7}表示的是2个链表的公共部分
// 这3个参数最后在后台会组装成为2个两个无环的单链表，且是有公共节点的    

// 示例2
// 输入：
// {1},{2,3},{}
// 返回值：
// {}

// 说明：
// 2个链表没有公共节点 ,返回null，后台打印{}       

// 知识点：双指针

// 双指针指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个指针（特殊情况甚至可以多个），两个指针或是同方向访问两个链表、或是同方向访问一个链表（快慢指针）、或是相反方向扫描（对撞指针），从而达到我们需要的目的。

// 思路：

// 如果两个链表有公共节点，那么它们后半部分都是相同的，我们要找的也就是后半部分的第一个节点。链表前半部分不同，长度也可能不同，因此同时遍历的话不一定就会同时到达第一个公共节点。

// 但是，如果我们能够找到长度差：

// int n = p1 - p2;
// 较长的链表指针先走nnn步：

// //假设pHead1更长
// for(int i = 0; i < n; i++)
//     pHead1 = pHead1.next;
// 然后两个指针分别走剩余的步数，就会同时到达第一个公共节点。

// 具体做法：

// step 1：单独的遍历两个链表，得到各自的长度。
// step 2：求得两链表的长度差nnn，其中较长的链表的指针从头先走nnn步。
// step 3：两链表指针同步向后遍历，遇到第一个相同的节点就是第一个公共节点。


// 如果链表A和B有一个为空，两者无法相交，返回null。 
// 都不为空时，创建p1和p2分别指向A和B的头节点。p1和p2不相等就移动p1，p2遍历两个链表。
// 当p1走到尾指向null，p2指向c3时，将p1移动到链表B的头节点。
// p1往前走到b2，同时p2走到未指向null，将p2移动链表A的头节点。
// 同时再移动下一个节点就能找到相交节点
// 这样做的原因是让两个指针移动的步长相等，步长相等，如果有相交的节点，就可以同时到达，跳出循环，返回p1或p2
// 如果没有相交的节点，两个指针会遍历完两个链表，都会指向null，返回，

class ListNode {
    val: number
    next: ListNode | null
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val === undefined ? 0 : val)
        this.next = (next === undefined ? null : next)
    }
}

/**
 * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
 *
 * 
 * @param pHead1 ListNode类 
 * @param pHead2 ListNode类 
 * @return ListNode类
 */
export function FindFirstCommonNode(pHead1: ListNode, pHead2: ListNode): ListNode {
    if (!pHead1 || !pHead2) return null

    let p1 = pHead1, p2 = pHead2

    while (p1 !== p2) {
        p1 = p1 === null ? pHead2 : p1.next
        p2 = p2 === null ? pHead1 : p2.next
    }

    return p1
}


// 描述
// 将给出的链表中的节点每 k 个一组翻转，返回翻转后的链表
// 如果链表中的节点数不是 k 的倍数，将最后剩下的节点保持原样
// 你不能更改节点中的值，只能更改节点本身。

// 数据范围：  0≤n≤2000 ， 1≤k≤2000 ，链表中每个元素都满足0≤val≤1000
// 要求空间复杂度 O(1)O(1)，时间复杂度 O(n)O(n)
// 例如：
// 给定的链表是 1→2→3→4→5
// 对于 k = 2k=2 , 你应该返回 2→1→4→3→5
// 对于 k = 3k=3 , 你应该返回 3→2→1→4→5

// 示例1
// 输入：
// {1,2,3,4,5},2

// 返回值：
// {2,1,4,3,5}

// 示例2
// 输入：
// {},1

// 返回值：
// {}


// 思路：

// 现在我们想一想，如果拿到一个链表，想要像上述一样分组翻转应该做些什么？首先肯定是分段吧，至少我们要先分成一组一组，才能够在组内翻转，之后就是组内翻转，最后是将反转后的分组连接。

// 但是连接的时候遇到问题了：首先如果能够翻转，链表第一个元素一定是第一组，它翻转之后就跑到后面去了，而第一组的末尾元素才是新的链表首，我们要返回的也是这个元素，而原本的链表首要连接下一组翻转后的头部，即翻转前的尾部，如果不建立新的链表，看起来就会非常难。但是如果我们从最后的一个组开始翻转，得到了最后一个组的链表首，是不是可以直接连在倒数第二个组翻转后的尾（即翻转前的头）后面，这样从后往前是不是看起来就容易多了。

// 怎样从后往前呢？我们这时候可以用到自上而下再自下而上的递归或者说栈。接下来我们说说为什么能用递归？如果这个链表有nnn个分组可以反转，我们首先对第一个分组反转，那么是不是接下来将剩余n−1n - 1n−1个分组反转后的结果接在第一组后面就行了，那这剩余的n−1n - 1n−1组就是一个子问题。我们来看看递归的三段式模版：

// 终止条件： 当进行到最后一个分组，即不足k次遍历到链表尾（0次也算），就将剩余的部分直接返回。
// 返回值： 每一级要返回的就是翻转后的这一分组的头，以及连接好它后面所有翻转好的分组链表。
// 本级任务： 对于每个子问题，先遍历k次，找到该组结尾在哪里，然后从这一组开头遍历到结尾，依次翻转，结尾就可以作为下一个分组的开头，而先前指向开头的元素已经跑到了这一分组的最后，可以用它来连接它后面的子问题，即后面分组的头。
// 具体做法：

// step 1：每次从进入函数的头节点优先遍历链表k次，分出一组，若是后续不足k个节点，不用反转直接返回头。
// step 2：从进入函数的头节点开始，依次反转接下来的一组链表，反转过程同BM1.反转链表。
// step 3：这一组经过反转后，原来的头变成了尾，后面接下一组的反转结果，下一组采用上述递归继续。

class ListNode {
    val: number
    next: ListNode | null
    constructor(val?: number, next?: ListNode | null) {
        this.val = (val === undefined ? 0 : val)
        this.next = (next === undefined ? null : next)
    }
}

export function reverseKGroup(head: ListNode, k: number): ListNode {
    let cache: ListNode[] = []
    let node: ListNode = head

    while (node != null) {
        cache.push(node)
        node = node.next
    }

    for (let i = 0; i < cache.length; i += k) {
        if (cache.length - i >= k) {
            let a = cache.splice(i, k).reverse()
            cache.splice(i, 0, ...a)
        }
    }

    for (let i = 0; i < cache.length; i++) {
        cache[i].next = cache[i + 1]
    }

    return cache[0]
}
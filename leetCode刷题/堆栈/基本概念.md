JS的内存空间主要分为代码空间、栈空间和堆空间，代码空间用于存放可执行代码，栈空间用于存放大小固定的数据。当调用栈完成当前的执行上下文时，需要进行垃圾回收，会触发JS的垃圾回收器自动回收，其主要分为栈空间回收和堆空间回收。

- 存放在栈空间的数据通过移动`ESP`指针回收
- 存放在堆空间的数据通过副垃圾回收器(新生代) 和 主垃圾回收器(老生代) 进行回收

<img src="https://oscimg.oschina.net/oscnet/up-724979cffa79eeddb8a30a6a1eed6d7a009.png" alt="img" style="zoom:50%;" />



### 1、栈空间回收

JS 执行代码时，主线程上会存在`ESP`指针，指向调用栈当前正在执行的上下文，当`ESP`指针向下移动时，JS引擎会销毁存放在栈空间无效的执行上下文。

<img src="https://oscimg.oschina.net/oscnet/up-4fccc0a7bda0d36046c0b73dd82236fade3.png" alt="img" style="zoom:50%;" />



### 2、堆空间回收

V8 把堆空间分成新生代和老生代两个区域，新生代用来存放生存周期较短的对象，一般只支持1-8M的容量，而周期较长、容量较大的对象则存放在老生代。

<img src="https://oscimg.oschina.net/oscnet/up-fb90d2a82aedbd5b9759e90e9caecae731e.png" alt="img" style="zoom:75%;" />

两块区域使用了不同的回收器，但流程是相同的

- 标记：是否活动对象
- 垃圾清理：回收非活动对象的内存空间
- 内存整理：内存碎片

#### 2.1、副垃圾回收器

它采⽤ Scavenge 算法及对象晋升策略来进⾏垃圾回收。

#### 2.1.1、 Scavenge算法

把新生代空间划分为对象区域和空闲区域，对区域内的对象进行标记，接着将对象区域活动对象**有序地**复制到空闲区域，完成之后两个区域进行翻转。

#### 2.1.2、对象晋升策略

新生代区域很小，因此只要对象经过两次垃圾回收之后依旧存活，就会被晋升到老生代区域。

### 2.2、主垃圾回收器

它主要采用增量标记算法，把垃圾回收拆成一个个小任务，穿插在JS中执行，进而防止垃圾回收执行打断了JS的运行，导致的页面卡顿问题。